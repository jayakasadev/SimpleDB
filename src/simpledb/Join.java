package simpledb;
import java.util.*;
import java.io.*;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private JoinPredicate _predicate;
    private DbIterator _outerRelation;
    private DbIterator _innerRelation;
    private Iterator<Tuple> _outerPage=null;
    private Iterator<Tuple> _innerPage=null;

    private Tuple _outerRecent=null;
    private Tuple _innerRecent=null;
    private Tuple _join = null;
    
    private boolean _outernext = true;
    private boolean _isSorted = false;
    private ArrayList<Tuple> outer = null;
    private ArrayList<Tuple> inner = null;
    private ArrayList<Tuple> outerSort = null;
    private ArrayList<Tuple> innerSort = null;

    private int _joinType = 0;
    private int _numMatches =0;
    private int _numComp=0;
  
    public static final int SNL = 0;
    public static final int PNL = 1;    
    public static final int BNL = 2;    
    public static final int SMJ = 3;    
    public static final int HJ = 4;
    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
    	//IMPLEMENT THIS
    	//System.out.println("JOIN CONSTRUCTOR");
    	//System.out.println("Outer Class" + child1.getClass());
    	//System.out.println("Inner Class" + child2.getClass() + "\n");
    	
    	//deal with params here
    	this._predicate = p;
    	
    	//int pagesO = ((SeqScan)child1).getPagesRead();
    	//int pagesI = ((SeqScan)child2).getPagesRead();
    	
    	this._outerRelation = child1;
    	this._innerRelation = child2;
    	
    	/*
    	if(pagesO > pagesI || pagesO == pagesI){
    		this._outerRelation = child1;
        	this._innerRelation = child2;
    	}
    	else{
    		this._innerRelation = child1;
        	this._outerRelation = child2;
    	}
    	*/
    	
    	//String callerClassName = new Exception().getStackTrace()[1].getClassName();
    	//String calleeClassName = new Exception().getStackTrace()[0].getClassName();
    	
    	//System.out.println(calleeClassName);
    	//System.out.println(callerClassName);
    	
    }

    public void setJoinAlgorithm(int joinAlgo){
    	_joinType = joinAlgo;
    }
    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
		//IMPLEMENT THIS
    	//method gets the new column setup names for the join about to happen
	    return TupleDesc.combine(_outerRelation.getTupleDesc(), _innerRelation.getTupleDesc());
    }

    public void open() throws DbException, NoSuchElementException, TransactionAbortedException, IOException {
		//IMPLEMENT THIS
    	_outerRelation.open();
    	_innerRelation.open();
    	
    	//get the first page and an iterator on the tuples
    	//_outerPage = ((Page)((HeapFileIterator)((SeqScan)_outerRelation).getIterator()).getCurrentPage()).iterator();
    	//_innerPage = ((Page)((HeapFileIterator)((SeqScan)_innerRelation).getIterator()).getCurrentPage()).iterator();
    	
    	if(_outerPage == null){
    		outer = new ArrayList<Tuple>();
    		while(_outerRelation.hasNext()){
    			Tuple t = _outerRelation.next();
    			//System.out.println(t);
    			if(t != null){
    				outer.add(t);
    			}
    			
    		}
    		_outerRelation.rewind();
    	}
    	if(_innerPage == null){
    		inner = new ArrayList<Tuple>();
    		while(_innerRelation.hasNext()){
    			Tuple t = _innerRelation.next();
    			//System.out.println(t);
    			if(t != null){
    				inner.add(t);
    			}
    		}
    		_innerRelation.rewind();
    	}
		
		_outerPage = outer.iterator();
		_innerPage = inner.iterator();
		
		//System.out.println(outer);
		//System.out.println(inner);
		/*
		sort("inner");
		sort("outer");
		
		System.out.println("Sorted " + outerSort);
		System.out.println("Sorted " + innerSort);
		*/
    }

    public void close() {
    	//IMPLEMENT THIS
    	_outerRelation.close();
    	_innerRelation.close();
    }

    public void rewind() throws DbException, TransactionAbortedException, IOException {
    	//IMPLEMENT THIS
    	this.close();
    	this.open();
    	
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {
    	switch(_joinType){
    		case SNL: 
    			return SNL_readNext();
    		case PNL: 
    			return PNL_readNext();
    		case BNL: 
    			return BNL_readNext();
    		case SMJ: 
    			return SMJ_readNext();
    		case HJ: 
    			return HJ_readNext();
    		default: 
    			return SNL_readNext();
    	}
    }

    protected Tuple SNL_readNext() throws TransactionAbortedException, DbException {
    	//IMPLEMENT THIS
    	//simple nested loop
    	//get the next tuple 
    	//System.out.println("SNL START");
    	//return null;
    	
		if(!_innerPage.hasNext()){
			_innerPage = inner.iterator();
			_innerRecent = null;
			_outernext = true;
		}
   		while(_innerPage.hasNext()){
   			if(_outernext){
   				if(_outerPage.hasNext()){
   					_outernext = false;
   					_outerRecent = _outerPage.next();
   					//System.out.println(_outerRecent);
   				}
   				else{
   					return null;
   				}
   			}
   			_innerRecent = _innerPage.next();
			//System.out.println("Problem Area " + _innerRecent);
			
			if(_innerRecent == null){
				continue;
			}
			
    		_numComp++;
    		if(_predicate.filter(_outerRecent, _innerRecent)){
    			_numMatches++;
    			_join = joinTuple(_outerRecent, _innerRecent, getTupleDesc());
    			//System.out.println(_join);
    			return _join;
    		}
    			
    		if(!_innerPage.hasNext()){
    	
    			_innerPage = inner.iterator();
    			_innerRecent = null;
    			_outernext = true;
    		}
    	}
    	_outerRecent = null;
    	//System.out.println("NULL");
    	return null;
    	
    }


    protected Tuple PNL_readNext() throws TransactionAbortedException, DbException {
    	//IMPLEMENT THIS (EXTRA CREDIT ONLY)
    	//page nested loop
    	System.out.println("PNL START");
    	return SNL_readNext();
    }


    protected Tuple BNL_readNext() throws TransactionAbortedException, DbException {
    	//no need to implement this
    	return null;
    }


    protected Tuple SMJ_readNext() throws TransactionAbortedException, DbException {
    	//IMPLEMENT THIS. YOU CAN ASSUME THE JOIN PREDICATE IS ALWAYS =
    	//sort merge join
    	//return null;
    	
    	if(!_isSorted){
    		sort("inner");
    		sort("outer");
    		//outer = outerSort;
    		//inner = innerSort;
    		
    		//System.out.println("Sorted " + outerSort);
    		//System.out.println("OUTER " + outer);
    		//System.out.println("Sorted " + innerSort);
    		//System.out.println("INNER " + inner);
    		_isSorted = true;
    		
    		_outerPage = outerSort.iterator();
    		_innerPage = innerSort.iterator();
    	}
    	
		if(!_innerPage.hasNext()){
			_innerPage = innerSort.iterator();
			_innerRecent = null;
			_outernext = true;
		}
   		while(_innerPage.hasNext()){
   			if(_outernext){
   				if(_outerPage.hasNext()){
   					_outernext = false;
   					_outerRecent = _outerPage.next();
   					//System.out.println(_outerRecent);
   				}
   				else{
   					return null;
   				}
   			}
   			
   			_innerRecent = _innerPage.next();
			//System.out.println("\t" + _innerRecent);
   			if(_innerRecent == null){
				continue;
			}
    		_numComp++;
    		if(_predicate.filter(_outerRecent, _innerRecent)){
    			_numMatches++;
    			_join = joinTuple(_outerRecent, _innerRecent, getTupleDesc());
    			//System.out.println(_join);
    			return _join;
    		}
    			
    		if(!_innerPage.hasNext()){
    	
    			_innerPage = innerSort.iterator();
    			_innerRecent = null;
    			_outernext = true;
    		}
    	}
    	_outerRecent = null;
    	//System.out.println("NULL");
    	return null;
    	
    }
    
    private void sort(String relation){
    	//System.out.println("SORT START " + relation);
    	
    	ArrayList<Tuple> sorted = new ArrayList<Tuple>();
    	Iterator<Tuple> page = null;
    	int numFields = 0;
    	
    	if(relation.equals("inner")){
    		page = inner.iterator();
    		numFields = _innerRelation.getTupleDesc().numFields();
    	}
    	if(relation.equals("outer")){
    		page = outer.iterator();
    		numFields = _outerRelation.getTupleDesc().numFields();
    	}
    	
    	//Predicate.Op greater = Predicate.Op.getOp(1);
    	//Predicate.Op eq = Predicate.Op.getOp(0);
    	//Predicate.Op less = Predicate.Op.getOp(2);
    	//System.out.println("END1");
    	//Tuple temp = page.next();
    	//System.out.println(temp);
    	sorted.add(page.next());
    	//System.out.println("END2");
    	
    	//sort inner list based on first field
    	while(page.hasNext()){
    		//tuple to add
    		Tuple newTuple = page.next();
    		//System.out.println(newTuple);
    		//System.out.println(sorted);
    		
    		//tuple in list
    		Tuple inList = null;
    		
    		boolean added = false;
    		int loc = 0;
    		for(int a = 0; a < sorted.size(); a++){
    			inList = sorted.get(a);
    			//only sorting based on the first field
    			int compare = getField(inList, 0).compareTo(getField(newTuple, 0));
    			//match
    			if(compare <= 0){
    				sorted.add(loc, newTuple);
    				added = true;
    				break;
    			}
    		}
    		//added at the end
    		if(!added){
        		sorted.add(newTuple);
    		}
    	}
    	
    	if(relation.equals("inner")){
    		innerSort = sorted;
    	}
    	if(relation.equals("outer")){
    		outerSort = sorted;
    	}
    }

    protected Tuple HJ_readNext() throws TransactionAbortedException, DbException {
    	//no need to implement this
    	return null;
    }


    private Tuple joinTuple(Tuple outer, Tuple inner, TupleDesc tupledesc){
    	//IMPLEMENT THIS
    	Tuple t = new Tuple(tupledesc);
        int numFields1 = outer.getTupleDesc().numFields();
        int numFields2 = inner.getTupleDesc().numFields();
        
        for (int i = 0; i < numFields1; i++)
            t.setField(i, outer.getField(i));
        for (int i = 0; i < numFields2; i++)
            t.setField(i + numFields1, inner.getField(i));

        //System.out.println(t);
        return t;
    }
    
    private String getField(Tuple t, int i){
            return "" + t.getField(i);
    }

    public int getNumMatches(){
    	return _numMatches;
    }
    public int getNumComp(){
    	return _numComp;
    }
}
